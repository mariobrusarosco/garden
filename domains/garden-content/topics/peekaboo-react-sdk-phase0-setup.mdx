---
title: "Peek-a-boo React SDK: Phase 0 Setup & Environment Architecture"
summary: "Setting up environment-aware feature flags with proper schema design, migrations, and SDK service endpoints for the React SDK"
category: "architecture"
icon: "react"
author: mariobrusarosco.github.com
related-topics:
  - "prisma"
  - "migrations"
  - "environment-variables"
  - "feature-flags"
  - "react-sdk"
reference-links:
  - link: "/home/mario/coding/peek-a-boo/planning/react-sdk-master-plan.md"
    text: "React SDK Master Plan"
  - link: "/home/mario/coding/peek-a-boo/planning/peekaboo-react-sdk-pdr.md"
    text: "Product Design Review"
planted-in: 2025-11-08
last-watered-in: 2025-11-16
---

# Recap

Successfully completed **Phase 0 (Prerequisites + Package Setup)** for the Peek-a-boo React SDK. This phase accomplished two major goals:

1. **Prerequisites:** Implemented environment-aware feature flags with proper database schema, migrations, and SDK service endpoints. The critical blocker was **lack of environment support** in the database schema - feature flags were only scoped to organization/project without dev/staging/prod separation.

2. **Package Setup:** Created the `@peek-a-boo/react-sdk` package structure with TypeScript, Vite build configuration, and monorepo integration ready for Phase 1 implementation.

**Key Achievement:** Created a production-ready foundation where flags can be managed per environment, with proper API endpoints for the React SDK to consume, and a zero-dependency package structure ready for core client implementation.

# The Problem

Initial assessment revealed the React SDK design assumed:
```typescript
GET /api/v1/flags?environment=production
```

But the database schema had NO environment concept:
```prisma
model FeatureFlag {
  id             String
  name           String
  value          Json
  projectId      String
  organizationId String
  // ❌ NO environment field
}
```

Flags were only scoped to Organization + Project. This wouldn't support:
- Different flag states in dev vs production
- Safe testing before production rollout
- Environment-specific feature releases

# The Solution

## 1. Schema Evolution

Added environment support with proper constraints:

```prisma
model FeatureFlag {
  id          String      @id @default(cuid())
  key         String      // Unique identifier (e.g., "new-checkout")
  name        String      // Display name
  description String?     // Optional description
  enabled     Boolean     @default(false)
  value       Json        // For future variations
  environment Environment @default(DEVELOPMENT)

  projectId      String
  organizationId String

  // ONE flag key per project per environment
  @@unique([key, projectId, environment])
}

enum Environment {
  DEVELOPMENT
  STAGING
  PRODUCTION
}
```

**Critical Design Decision:** The unique constraint `[key, projectId, environment]` allows the same flag key (e.g., "new-checkout") to exist with different states across environments.

## 2. Migration Strategy

**Lesson Learned:** NEVER use workarounds for migrations. Always create proper migration files.

The correct flow:
```bash
cd packages/core
npx prisma migrate dev --name add_environment_and_key_to_feature_flags
```

This creates:
- Migration SQL file in `prisma/migrations/`
- Updates Prisma client with new types
- Applies changes to database
- Maintains migration history for production deployments

**Why this matters:**
- ✅ Reproducible across environments
- ✅ Can be committed to git
- ✅ Can be rolled back
- ✅ Safe for production with `prisma migrate deploy`

## 3. SDK Service Runtime API

Created a new domain module `sdk-runtime` (separate from admin `feature-flags` module):

```typescript
// apps/sdk-service/src/domains/sdk-runtime/

GET /api/v1/flags?projectId={id}&environment={env}
// Returns: { flags: [...], environment: "DEVELOPMENT" }

GET /api/v1/flags/{key}?projectId={id}&environment={env}
// Returns: { key, enabled, value, environment, ... }
```

**Design Pattern:** Runtime API is separate from admin API because:
- Different authentication (SDK keys vs user auth)
- Different data needs (runtime needs minimal, fast responses)
- Different caching strategies
- Different rate limiting requirements

## 4. Environment Variable Architecture

**Problem:** Hardcoded organization IDs scattered across Dashboard and seed file led to foreign key violations after database resets.

**Solution:** Single source of truth via environment variables:

```bash
# packages/core/.env
SEED_ORGANIZATION_ID="cmhqxjwpw000e2ikeps545uou"

# apps/dashboard/.env.local
ORGANIZATION_ID="cmhqxjwpw000e2ikeps545uou"
```

Seed file uses `upsert` to ensure consistent org ID:
```typescript
const SEED_ORG_ID = process.env.SEED_ORGANIZATION_ID || 'default-id';

await prisma.organization.upsert({
  where: { id: SEED_ORG_ID },
  update: { name: organization.name },
  create: { id: SEED_ORG_ID, name: organization.name },
});
```

**Benefits:**
- Seed always creates same org ID
- Dashboard always uses same org ID
- Easy to change in one place
- No foreign key violations

# Anatomy of a Complete System Fix

## Phase 1: Schema Changes
1. Update Prisma schema
2. Run migration (interactive required)
3. Verify Prisma client regenerated

## Phase 2: Cascade Updates
Think through the entire system:
- **Seed file** - Must use new required fields
- **Service DTOs** - Must include new fields
- **Dashboard actions** - Must send new fields
- **API endpoints** - Must handle new fields

**Critical Thinking Required:** When changing schema, don't just fix one file. Trace through:
1. Where is data created? (Dashboard form → action → API)
2. Where is data read? (API endpoints → SDK)
3. Where is data seeded? (Seed file)

Each layer needs updating, not just the schema.

## Phase 3: Validation
Test the entire flow:
```bash
# 1. Seed database
pnpm run prisma:seed

# 2. Create flag via Dashboard
# (Opens form, submits, checks for errors)

# 3. Query via API
curl "http://localhost:6001/api/v1/flags?projectId=xxx&environment=development"

# 4. Verify different environments work
curl "http://localhost:6001/api/v1/flags?projectId=xxx&environment=production"
```

# Package Setup & Monorepo Integration

With the database foundation and API endpoints complete, Phase 0 continues with creating the React SDK package structure and integrating it into the Turborepo monorepo.

## Package Structure Created

```
packages/react-sdk/
├── src/
│   ├── client/          # Vanilla JS client (no React)
│   ├── react/           # React-specific code
│   │   └── hooks/       # useFeatureFlag, useFeatureFlags
│   └── test/            # Test utilities and setup
├── package.json
├── tsconfig.json
└── vite.config.ts
```

**Design Decision:** Separate `client/` from `react/` to enable future framework adapters (Vue, Svelte) to reuse the core client logic.

## Package Configuration

**packages/react-sdk/package.json:**
```json
{
  "name": "@peek-a-boo/react-sdk",
  "version": "0.0.1",
  "type": "module",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",

  "peerDependencies": {
    "react": ">=16.8.0"  // Hooks support
  },

  "devDependencies": {
    "@types/react": "^18.2.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/react-hooks": "^8.0.1",
    "@vitest/ui": "^1.0.0",
    "jsdom": "^23.0.0",
    "msw": "^2.0.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0"
  }
}
```

**Key Characteristics:**
- **Zero runtime dependencies** - Only React as peer dependency
- **ESM + CJS outputs** - Supports both module systems
- **Testing stack:** Vitest + Testing Library + MSW (for API mocking)
- **Target bundle size:** less than 10KB (goal from PDR)

## TypeScript Configuration

**packages/react-sdk/tsconfig.json:**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "jsx": "react",
    "declaration": true,    // Generate .d.ts files
    "outDir": "dist",
    "strict": true,         // Full type safety
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
```

**Design Choices:**
- `strict: true` - Catch errors at compile time
- `declaration: true` - TypeScript users get full autocomplete
- `moduleResolution: "bundler"` - Modern resolution for Vite
- `noEmit: true` - Vite handles building, TSC only type-checks

## Vite Build Configuration

**packages/react-sdk/vite.config.ts:**
```typescript
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.ts'),
      name: 'PeekabooReactSDK',
      formats: ['es', 'cjs'],
      fileName: (format) => `index.${format === 'es' ? 'esm' : format}.js`
    },
    rollupOptions: {
      external: ['react'],
      output: {
        globals: { react: 'React' }
      }
    }
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts'
  }
});
```

**Build Strategy:**
- **Library mode** - Not building an app, building a distributable package
- **External React** - Don't bundle React, expect consumer to provide it
- **Two formats:**
  - `dist/index.esm.js` - For modern bundlers (tree-shakeable)
  - `dist/index.cjs.js` - For legacy Node/CommonJS

**Test Strategy:**
- jsdom environment (simulates browser DOM)
- Global test utilities (describe, it, expect available everywhere)
- MSW setup file for mocking API requests

## Critical Fix: Vitest Types

Initial version used `import { defineConfig } from 'vite'` which caused TypeScript error:
```
Object literal may only specify known properties, and 'test' does not exist
```

**Solution:** Import from `vitest/config` instead:
```typescript
import { defineConfig } from 'vitest/config';  // ✅ Includes test types
```

This provides proper typing for the `test` configuration block.

## Monorepo Integration

The React SDK automatically integrates with the existing Turborepo configuration:

**Root turbo.json:**
```json
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    }
  }
}
```

**Why it works:**
- `"^build"` dependency means build dependencies first
- `"dist/**"` output pattern matches React SDK output
- No package-specific configuration needed

**Build command:**
```bash
# Build React SDK (builds @peek-a-boo/core first if needed)
pnpm build --filter=@peek-a-boo/react-sdk

# Or use the root-level script
pnpm build:react-sdk
```

## Installation & Verification

```bash
# Install all dependencies
pnpm install

# Verify TypeScript setup (will error until source files created)
cd packages/react-sdk
pnpm run type:check

# Expected: "No inputs were found" - normal, no .ts files yet
```

## Phase 0 Completion Status

**Prerequisites:** ✅
- Schema supports environments
- Migration applied
- API endpoints created
- Environment variables configured

**Package Setup:** ✅
- Directory structure created
- package.json configured
- TypeScript configured
- Vite build configured
- Monorepo integration verified
- Dependencies installed

**Ready for Phase 1:** ✅ All foundational work complete

# Used in Projects

- **Peek-a-boo Feature Flag Platform** - Foundation for React SDK development
- Pattern applicable to any feature flag system requiring environment separation

# Key Lessons

## 1. Schema Design First
Don't build APIs before validating the database schema supports your use case. The React SDK design assumed environment support - checking the schema FIRST saved potential rework.

## 2. Think Systemically
Changing a Prisma schema isn't done until:
- Migration created ✅
- Seed updated ✅
- DTOs updated ✅
- API endpoints updated ✅
- Dashboard updated ✅
- All tested ✅

Missing ANY step breaks the system.

## 3. Environment Variables > Hardcoding
A single hardcoded ID becomes technical debt the moment you need to reset the database. Use env vars from day 1.

## 4. Separation of Concerns
Runtime API (`/api/v1/flags`) separate from Admin API (`/feature-flags`) because they serve different purposes, different clients, different security models.

## 5. Documentation Matters
The `.env.example` files with comments explain WHY each variable exists and HOW they relate:
```bash
# Development organization ID (must match SEED_ORGANIZATION_ID in packages/core/.env)
ORGANIZATION_ID=cmhqxjwpw000e2ikeps545uou
```

# Next Steps

With Phase 0 complete, the React SDK can now proceed:

**Phase 1: Core Client Implementation**
- TypeScript types matching API response
- HTTP client with retry logic
- FeatureFlagClient (vanilla JS)

The foundation is solid:
- ✅ Schema supports environments
- ✅ API endpoints ready
- ✅ Data seeded and testable
- ✅ Environment variables configured

# Technical Debt Identified

1. **Hardcoded Organization Concept** - Dashboard still requires organization context. Future: Multi-tenant support needed.

2. **No API Key Authentication** - Runtime endpoints currently accept any projectId. Future: Implement SDK key validation.

3. **No Rate Limiting** - Production deployment needs rate limiting on runtime endpoints.

4. **Manual Param Awaiting** - Next.js 15 warnings about `params.id` needing await. Minor but should be addressed.

# Commands Reference

```bash
# Database Migration
cd packages/core
npx prisma migrate dev --name your_migration_name

# Seed Database
pnpm run prisma:seed

# Test Runtime API
curl "http://localhost:6001/api/v1/flags?projectId=ID&environment=development"

# Check Migration Status
cd packages/core
npx prisma migrate status
```

# Debugging Tips

**Foreign Key Violations:**
- Check organization/project IDs exist in database
- Verify env vars match between seed and dashboard
- Use `npx prisma studio` to inspect actual IDs

**Migration Issues:**
- Always run from `packages/core` directory
- Ensure `.env` file exists in `packages/core`
- Use `prisma migrate reset --force` to start fresh (dev only!)

**Type Errors After Schema Changes:**
- Ensure Prisma client regenerated: `npx prisma generate`
- Restart TypeScript server in IDE
- Check all imports use `Environment` enum type, not strings
