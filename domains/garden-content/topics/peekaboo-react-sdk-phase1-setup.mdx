---
title: "Peek-a-boo React SDK: Phase 1 Core Client (Vanilla TypeScript)"
summary: "Building the vanilla TypeScript core client with proper type definitions, HTTP client with retry logic, and the FeatureFlagClient class"
category: "architecture"
icon: "react"
author: mariobrusarosco.github.com
related-topics:
  - "typescript"
  - "monorepo"
  - "pnpm-workspaces"
  - "feature-flags"
  - "react-sdk"
reference-links:
  - link: "/home/mario/coding/peek-a-boo/planning/react-sdk-master-plan.md"
    text: "React SDK Master Plan"
  - link: "/home/mario/coding/peek-a-boo/planning/peekaboo-react-sdk-pdr.md"
    text: "Product Design Review"
  - link: "/home/mario/coding/peek-a-boo/packages/react-sdk/src/client/types.ts"
    text: "Type Definitions Source"
planted-in: 2025-11-16
last-watered-in: 2025-11-16
series:
  - "creating-a-feature-flag-saas-platform"
---

# Recap

Phase 1 focuses on building the vanilla TypeScript core client - the foundation that will later be wrapped by React hooks. This phase creates the framework-agnostic logic for fetching and managing feature flags, ensuring we can potentially support other frameworks (Vue, Svelte) in the future.

**Key Achievement:** Created type-safe client foundation that imports shared types from `@peek-a-boo/core`, maintaining single source of truth in the monorepo.

# Phase 1.1: Type Definitions

## The Problem

The React SDK needs type definitions for:
- Feature flags (structure matching API responses)
- Client configuration (projectId, environment, baseUrl, timeout)
- Hook return values (enabled, value, loading, error states)
- Error handling (custom error classes with codes)

**Initial mistake:** Almost created duplicate `FeatureFlag` and `Environment` types locally in the React SDK.

**Critical realization:** These types already exist in `@peek-a-boo/core` from the Prisma schema. Creating duplicates would:
- ‚ùå Create two sources of truth
- ‚ùå Cause type mismatches if schema changes
- ‚ùå Defeat the purpose of a monorepo

## The Solution: Import from Core

### Single Source of Truth Pattern

```typescript
// src/client/types.ts

// ============================================================================
// IMPORTED FROM CORE (Single Source of Truth)
// ============================================================================

import type { FeatureFlag, Environment } from '@peek-a-boo/core';

// Re-export for SDK consumers
export type { FeatureFlag, Environment };

// ============================================================================
// SDK-SPECIFIC TYPES
// ============================================================================

export interface ClientConfig {
  projectId: string;
  environment: Environment;  // ‚Üê Uses imported type
  baseUrl?: string;
  timeout?: number;
}

export interface FlagResult<T = unknown> {
  enabled: boolean;
  value?: T;
  loading: boolean;
  error?: Error;
}
```

**The pattern:**
- **Import from core:** Database models, enums, anything from Prisma
- **Create in SDK:** API shapes, client configuration, React-specific types
- **Re-export:** Make core types available to SDK consumers

### Adding the Workspace Dependency

To import from `@peek-a-boo/core`, we needed to add it as a dependency:

```json
// packages/react-sdk/package.json
{
  "name": "@peek-a-boo/react-sdk",
  "dependencies": {
    "@peek-a-boo/core": "workspace:*"
    //                  ^^^^^^^^^^^^
    //                  pnpm workspace protocol
  }
}
```

**What `workspace:*` does:**
1. Tells pnpm to link the local `@peek-a-boo/core` package
2. Creates symlink: `node_modules/@peek-a-boo/core` ‚Üí `../../core`
3. No npm registry lookup - uses local code
4. Turborepo uses this to determine build order (core builds before react-sdk)

**Installation:**
```bash
# Added dependency to package.json, then:
pnpm install

# Result:
# node_modules/@peek-a-boo/core ‚Üí ../../core (symlink created)
```

## SDK-Specific Types Created

### ClientConfig

```typescript
export interface ClientConfig {
  /** Project ID from Peek-a-boo dashboard */
  projectId: string;

  /** Environment to fetch flags for */
  environment: Environment;

  /** API base URL (defaults to http://localhost:6001 in development) */
  baseUrl?: string;

  /** Request timeout in milliseconds (default: 5000) */
  timeout?: number;
}
```

**Design decisions:**
- `projectId` is required (can't fetch flags without it)
- `environment` is required (flags are environment-specific)
- `baseUrl` is optional (defaults to local dev server)
- `timeout` is optional (sensible default of 5 seconds)

### FlagResult (Hook Return Type)

```typescript
export interface FlagResult<T = unknown> {
  /** Whether the flag is enabled */
  enabled: boolean;

  /** Flag value (typed based on generic parameter) */
  value?: T;

  /** Loading state (true while fetching) */
  loading: boolean;

  /** Error if fetch failed */
  error?: Error;
}
```

**Why generic `<T = unknown>`?**
Allows consumers to specify the value type:

```typescript
interface CheckoutConfig {
  timeout: number;
  retries: number;
}

const { enabled, value } = useFeatureFlag<CheckoutConfig>('new-checkout');
//                                        ^^^^^^^^^^^^^^^ Type parameter

if (enabled && value) {
  value.timeout  // ‚úÖ TypeScript knows this exists
}
```

**Default `unknown` instead of `any`:**
- Forces type checking before use (safer)
- Consumer must provide type or handle `unknown`
- Prevents accidental bugs from assuming structure

### PeekabooError (Custom Error Class)

```typescript
export class PeekabooError extends Error {
  constructor(
    message: string,
    public code: ErrorCode
  ) {
    super(message);
    this.name = 'PeekabooError';

    // Maintains proper stack trace (V8 only)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, PeekabooError);
    }
  }
}

export enum ErrorCode {
  INVALID_PROJECT_ID = 'INVALID_PROJECT_ID',
  INVALID_ENVIRONMENT = 'INVALID_ENVIRONMENT',
  NOT_FOUND = 'NOT_FOUND',
  HTTP_ERROR = 'HTTP_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN',
}
```

**Why custom error class?**
- Programmatic error handling (check `error.code`)
- Better error messages
- Clear distinction from generic errors

**Usage:**
```typescript
try {
  await client.initialize();
} catch (error) {
  if (error instanceof PeekabooError) {
    switch (error.code) {
      case ErrorCode.INVALID_PROJECT_ID:
        // Handle invalid project
        break;
      case ErrorCode.NETWORK_ERROR:
        // Handle network issues
        break;
    }
  }
}
```

### FlagsResponse (API Response Shape)

```typescript
export interface FlagsResponse {
  /** Array of feature flags */
  flags: FeatureFlag[];

  /** Environment the flags belong to */
  environment: string;
}
```

**Matches SDK service API:**
```bash
GET /api/v1/flags?projectId=xxx&environment=DEVELOPMENT

Response:
{
  "flags": [...],
  "environment": "DEVELOPMENT"
}
```

## Developer Experience Enhancements

### JSDoc Comments

Added JSDoc comments for IDE tooltips:

```typescript
/**
 * Configuration for FeatureFlagClient
 */
export interface ClientConfig {
  /** Project ID from Peek-a-boo dashboard */
  projectId: string;
  // ...
}
```

**When developers hover over `ClientConfig` in VS Code:**
- They see the description
- Each field shows its purpose
- No need to read source code

### Type-Only Exports

Used `export type` for type-only exports:

```typescript
// ‚úÖ Explicit type export
export type { FeatureFlag, Environment };

// ‚úÖ Runtime export
export { PeekabooError };
```

**Why this matters:**
- Bundlers can optimize better (know what's compile-time only)
- Prevents accidentally including types in runtime bundle
- Clearer intent when reading code

## Verification

```bash
# Type check passed
pnpm run type:check
# ‚úÖ No errors

# Verify symlink created
ls -la node_modules/@peek-a-boo/
# core -> ../../core  ‚úÖ
```

## Key Lessons

### 1. Think Monorepo-First

**Wrong approach:**
```typescript
// ‚ùå Duplicating types
export interface FeatureFlag {
  key: string;
  enabled: boolean;
  // ... duplicate from core
}
```

**Right approach:**
```typescript
// ‚úÖ Import from single source
import type { FeatureFlag } from '@peek-a-boo/core';
export type { FeatureFlag };
```

### 2. Workspace Dependencies Enable Sharing

```json
{
  "dependencies": {
    "@peek-a-boo/core": "workspace:*"
  }
}
```

This simple line:
- Links packages in monorepo
- Enables type sharing
- Tells Turborepo build order
- Maintains single source of truth

### 3. Generic Types for Flexibility

```typescript
export interface FlagResult<T = unknown> {
  value?: T;  // User can specify type
}
```

Gives consumers flexibility without complexity:
- Power users: Specify exact types
- Quick users: Use defaults (unknown)

### 4. JSDoc = Better DX

Small effort, huge impact:
```typescript
/** Project ID from Peek-a-boo dashboard */
projectId: string;
```

Developers see this in IDE tooltips - reduces documentation lookups.

# Phase 1.2: HTTP Client with Retry Logic

## The Purpose

Create a resilient HTTP client to communicate with the SDK service API endpoints (`GET /api/v1/flags`) with built-in retry logic, timeout handling, and proper error classification.

**Design Goal:** Zero dependencies - use native browser/Node.js APIs only.

## Key Features Implemented

### 1. Exponential Backoff Retry Strategy

When network errors occur (connection failures), retry with increasing delays:

```typescript
Attempt 1: Immediate
Attempt 2: Wait 500ms  (baseDelay * 2^0)
Attempt 3: Wait 1000ms (baseDelay * 2^1)
Attempt 4: Wait 2000ms (baseDelay * 2^2)
```

**Why exponential backoff?**
- Gives the server time to recover
- Prevents thundering herd (all clients retrying immediately)
- Industry standard pattern (AWS SDK, Google Cloud SDK use this)

**Implementation:**
```typescript
private async fetchWithRetry<T>(url: string, attempt: number): Promise<T> {
  try {
    // ... fetch logic
  } catch (error) {
    // Calculate delay: 500ms * 2^attempt
    const delay = this.retryConfig.baseDelay * Math.pow(2, attempt);
    await this.sleep(delay);
    return this.fetchWithRetry<T>(url, attempt + 1);
  }
}
```

### 2. Timeout Handling with AbortController

Use native `AbortController` - no dependencies needed!

```typescript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), this.timeout);

const response = await fetch(url, {
  signal: controller.signal  // ‚Üê Attach abort signal
});

clearTimeout(timeoutId);
```

**How it works:**
1. Create `AbortController`
2. Set timeout that calls `controller.abort()` after 5 seconds
3. Pass `controller.signal` to fetch
4. If timeout fires, fetch throws `AbortError`
5. Clear timeout if fetch succeeds

**Why AbortController?**
- Native API (no dependencies)
- Supported in all modern browsers + Node 18+
- Proper cancellation (not just ignoring the response)

### 3. Query Parameter Building

Clean API for building URLs with query params:

```typescript
client.get('/api/v1/flags', {
  projectId: 'xxx',
  environment: 'DEVELOPMENT'
})

// Internally builds:
// ‚Üí GET /api/v1/flags?projectId=xxx&environment=DEVELOPMENT
```

**Implementation:**
```typescript
private buildUrl(path: string, params?: Record<string, string>): string {
  const url = `${this.baseUrl}${path}`;

  if (!params || Object.keys(params).length === 0) {
    return url;
  }

  const searchParams = new URLSearchParams(params);
  return `${url}?${searchParams.toString()}`;
}
```

**Why URLSearchParams?**
- Native API (no dependencies)
- Automatically handles URL encoding
- Works with complex characters (spaces, special chars)

### 4. Error Classification (Smart Retry Logic)

**Not all errors should be retried!**

```typescript
// ‚úÖ RETRY: Network errors (transient failures)
fetch('http://api.example.com/flags')
// ‚Üí Connection refused ‚Üí RETRY
// ‚Üí DNS lookup failed ‚Üí RETRY
// ‚Üí Network cable unplugged ‚Üí RETRY

// ‚ùå DON'T RETRY: HTTP errors (persistent issues)
fetch('http://api.example.com/flags')
// ‚Üí 404 Not Found ‚Üí Throw immediately (flag doesn't exist)
// ‚Üí 500 Server Error ‚Üí Throw immediately (server bug, won't fix itself)
// ‚Üí 401 Unauthorized ‚Üí Throw immediately (wrong credentials)
```

**Implementation:**
```typescript
if (!response.ok) {
  // HTTP error (404, 500, etc.) - throw immediately, don't retry
  throw new PeekabooError(
    `HTTP ${response.status}: ${response.statusText}`,
    ErrorCode.HTTP_ERROR
  );
}

// ... later in catch block

if (error instanceof PeekabooError) {
  throw error;  // Already classified, don't retry
}

// Network error - retry with backoff
const isLastAttempt = attempt >= this.retryConfig.maxRetries;
if (isLastAttempt) {
  throw new PeekabooError(
    `Network error after ${attempt + 1} attempts: ${message}`,
    ErrorCode.NETWORK_ERROR
  );
}
```

**Why this matters:**
- Retrying 404s wastes time (flag still won't exist)
- Retrying 500s might overload already-struggling server
- Only network errors are transient and worth retrying

### 5. Simple Public API

```typescript
export class HttpClient {
  constructor(
    private baseUrl: string,
    private timeout: number = 5000
  ) {}

  async get<T>(path: string, params?: Record<string, string>): Promise<T>
}
```

**Usage:**
```typescript
const client = new HttpClient('http://localhost:6001', 5000);

const response = await client.get<FlagsResponse>('/api/v1/flags', {
  projectId: 'abc123',
  environment: 'DEVELOPMENT'
});

console.log(response.flags); // Array of FeatureFlag
```

## Design Decisions Explained

### Why Only GET Method?

```typescript
async get<T>(path: string, params?: Record<string, string>): Promise<T>
```

**MVP scope:**
- SDK only needs to **fetch** flags (read-only)
- No create/update/delete from client
- Keeps implementation simple

**Future phases:**
- If we add client-side flag creation ‚Üí Add `post()`
- If we add flag updates ‚Üí Add `patch()`
- For now: YAGNI (You Ain't Gonna Need It)

### Why No Authentication Yet?

```typescript
headers: {
  'Content-Type': 'application/json',
  // No Authorization header yet
}
```

**Reason:**
- Phase 0 SDK service endpoints don't require authentication
- API keys will be added in future phase when we implement SDK key generation in dashboard

**Future:**
```typescript
headers: {
  'Authorization': `Bearer ${this.apiKey}`,
  'Content-Type': 'application/json',
}
```

### Why Native Fetch (No Axios)?

**Benefits:**
- ‚úÖ Zero dependencies (smaller bundle)
- ‚úÖ Native to browsers + Node 18+
- ‚úÖ Built-in AbortController support
- ‚úÖ Simpler (no learning curve)

**Comparison:**
```typescript
// Our implementation (0 dependencies)
const client = new HttpClient('http://api.example.com');
const data = await client.get('/flags', { projectId: 'xxx' });

// With Axios (adds ~14KB to bundle)
import axios from 'axios';
const { data } = await axios.get('/flags', {
  params: { projectId: 'xxx' },
  timeout: 5000
});
```

**Trade-off:**
- We write more code (retry logic, timeout handling)
- But we control everything and have zero dependencies

### Configuration Defaults

```typescript
private readonly retryConfig: RetryConfig = {
  maxRetries: 3,    // Total 4 attempts (1 initial + 3 retries)
  baseDelay: 500,   // 500ms ‚Üí 1000ms ‚Üí 2000ms
};

constructor(
  private baseUrl: string,
  private timeout: number = 5000  // 5 second default
) {}
```

**Why these values?**
- **3 retries:** Industry standard, balances resilience vs responsiveness
- **500ms base delay:** Fast enough for users, slow enough to help recovery
- **5 second timeout:** Long enough for slow connections, short enough users won't wait forever

## Implementation Highlights

### Clean URL Building

```typescript
constructor(private baseUrl: string, ...) {
  // Remove trailing slash for consistent URL building
  this.baseUrl = baseUrl.replace(/\/$/, '');
}

private buildUrl(path: string, params?: Record<string, string>): string {
  const url = `${this.baseUrl}${path}`;
  // ...
}
```

**Handles edge cases:**
```typescript
// Both work correctly:
new HttpClient('http://localhost:6001/')  // ‚Üê trailing slash
new HttpClient('http://localhost:6001')   // ‚Üê no trailing slash

// Both produce: http://localhost:6001/api/v1/flags
```

### Proper Timeout Cleanup

```typescript
const timeoutId = setTimeout(() => controller.abort(), this.timeout);

try {
  const response = await fetch(url, { signal: controller.signal });
  clearTimeout(timeoutId);  // ‚Üê Important! Prevent memory leak
  // ...
} catch (error) {
  clearTimeout(timeoutId);  // ‚Üê Also clear on error
  // ...
}
```

**Why clear timeout?**
- If fetch succeeds quickly, timeout is still scheduled
- Clearing prevents unnecessary timer firing
- Prevents memory leaks in long-running apps

### Type-Safe Generic Response

```typescript
async get<T>(path: string, params?: Record<string, string>): Promise<T> {
  // ...
  return (await response.json()) as T;
}
```

**Usage with type safety:**
```typescript
interface FlagsResponse {
  flags: FeatureFlag[];
  environment: string;
}

const response = await client.get<FlagsResponse>('/api/v1/flags', {...});
//    ^^^^^^^^ TypeScript knows the shape!

response.flags.forEach(flag => {
  console.log(flag.key);  // ‚úÖ TypeScript knows FeatureFlag has .key
});
```

## Testing Strategy

**How we'll test this (Phase 1.4):**

```typescript
import { setupServer } from 'msw/node';
import { rest } from 'msw';

describe('HttpClient', () => {
  it('retries on network error', async () => {
    let attempts = 0;

    server.use(
      rest.get('/api/v1/flags', (req, res, ctx) => {
        attempts++;
        if (attempts < 3) {
          return res.networkError('Connection failed');
        }
        return res(ctx.json({ flags: [] }));
      })
    );

    const client = new HttpClient('http://localhost');
    const result = await client.get('/api/v1/flags');

    expect(attempts).toBe(3); // Retried 2 times, succeeded on 3rd
  });

  it('does not retry HTTP errors', async () => {
    let attempts = 0;

    server.use(
      rest.get('/api/v1/flags', (req, res, ctx) => {
        attempts++;
        return res(ctx.status(404));
      })
    );

    const client = new HttpClient('http://localhost');

    await expect(client.get('/api/v1/flags')).rejects.toThrow(
      PeekabooError
    );

    expect(attempts).toBe(1); // No retries on 404
  });
});
```

## Key Lessons

### 1. Retry Logic Isn't Simple

**What seems simple:**
```typescript
// ‚ùå Naive retry
for (let i = 0; i < 3; i++) {
  try {
    return await fetch(url);
  } catch {
    // Just retry
  }
}
```

**What's actually needed:**
- ‚úÖ Exponential backoff (not constant delay)
- ‚úÖ Error classification (don't retry everything)
- ‚úÖ Maximum attempts (don't retry forever)
- ‚úÖ Proper error messages (include attempt count)

### 2. Native APIs Are Powerful

We built production-ready HTTP client with:
- Zero dependencies
- ~200 lines of code
- Full TypeScript support
- Retry logic
- Timeout handling
- Query parameters

**All using native APIs:**
- `fetch` (HTTP requests)
- `AbortController` (cancellation)
- `URLSearchParams` (URL building)
- `setTimeout` (delays)

### 3. Error Classification Matters

Not all errors are equal:
- **Transient errors** (network) ‚Üí Retry makes sense
- **Permanent errors** (404, 500) ‚Üí Retry wastes time

**Real-world impact:**
- User sees "Loading..." for 10 seconds
- Because we're retrying a 404 that will never succeed
- Bad UX!

### 4. Cleanup Prevents Memory Leaks

```typescript
clearTimeout(timeoutId);  // Always clear timers
```

**In long-running apps (SPAs):**
- Forgotten timers accumulate
- Memory usage grows
- Browser slows down
- Eventually crashes

**Proper cleanup = Professional code**

# Phase 1.3: FeatureFlagClient - Bringing It All Together

## The Purpose

Create a client class that uses our HTTP client to fetch and manage feature flags with a simple, intuitive API. This is the vanilla JavaScript client that React hooks will wrap in Phase 2.

**Design Goals:**
- Lazy loading (don't fetch until needed)
- In-memory caching (fast lookups)
- Type-safe value access
- Graceful error handling
- Race condition protection

## Understanding `initialize()`: The Foundation

### The Goal: Lazy Loading

**Problem:** When should we fetch flags from the API?

**‚ùå Bad: Fetch in Constructor**
```
User creates client ‚Üí Immediate API call
   ‚Üì
const client = new FeatureFlagClient({...})  ‚Üê API call happens here!
```

**Why bad?**
- User can't handle errors during construction
- Blocks synchronously (constructors can't be async)
- Wastes network if user never uses the client

**‚úÖ Good: Lazy Loading with initialize()**
```
User creates client ‚Üí No API call (instant)
   ‚Üì
const client = new FeatureFlagClient({...})  ‚Üê Instant!
   ‚Üì
User calls initialize ‚Üí API call happens NOW
   ‚Üì
await client.initialize()  ‚Üê Can handle errors with try/catch
```

**Why good?**
- Instant construction (no blocking)
- User controls WHEN to fetch
- User can handle errors gracefully
- Testable (can mock initialize)

### Visual Flow: First Initialize Call

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User calls: await client.initialize()                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check: Is initialized already?                              ‚îÇ
‚îÇ ‚Üí this.initialized === false                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì NO
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check: Is initialization in progress?                       ‚îÇ
‚îÇ ‚Üí this.initializing === null                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì NO
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Start initialization:                                        ‚îÇ
‚îÇ this.initializing = this.fetchFlags()                       ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ State now:                                                   ‚îÇ
‚îÇ ‚Ä¢ this.initialized = false                                  ‚îÇ
‚îÇ ‚Ä¢ this.initializing = Promise<void> (pending)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ fetchFlags() runs:                                           ‚îÇ
‚îÇ   1. Call API: GET /api/v1/flags                            ‚îÇ
‚îÇ   2. Wait for response...                                   ‚îÇ
‚îÇ   3. Parse JSON                                             ‚îÇ
‚îÇ   4. Populate this.flags Map                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Success!                                                     ‚îÇ
‚îÇ State update:                                                ‚îÇ
‚îÇ ‚Ä¢ this.initialized = true                                   ‚îÇ
‚îÇ ‚Ä¢ this.initializing = null                                  ‚îÇ
‚îÇ ‚Ä¢ this.flags = Map with all flags                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Return to user                                               ‚îÇ
‚îÇ User's await completes                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Pattern 1: Idempotent (Safe to Call Multiple Times)

### What is "Idempotent"?

From mathematics: f(f(x)) = f(x)

In programming: **Calling a function multiple times has the same effect as calling it once.**

**Example:**
```typescript
await client.initialize();  // Fetches flags from API
await client.initialize();  // Does NOTHING (already initialized)
await client.initialize();  // Does NOTHING (already initialized)

// Only ONE API call was made!
```

### Visual Flow: Second Initialize Call

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User calls: await client.initialize() AGAIN                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Check: Is initialized already?                              ‚îÇ
‚îÇ ‚Üí this.initialized === true  ‚úÖ                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì YES!
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Return immediately                                           ‚îÇ
‚îÇ if (this.initialized) {                                     ‚îÇ
‚îÇ   return;  ‚Üê Early exit!                                    ‚îÇ
‚îÇ }                                                            ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ NO API CALL! ‚úÖ                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Why Idempotent Matters

```typescript
// React component might call initialize multiple times
useEffect(() => {
  client.initialize();  // First render
}, []);

useEffect(() => {
  client.initialize();  // Some other effect
}, [someDep]);

// ‚úÖ Only ONE API call (idempotent)
// ‚ùå Without idempotency ‚Üí TWO API calls (wasteful!)
```

## Pattern 2: Race Condition Protection

### The Problem: Concurrent Calls

```typescript
// User accidentally calls initialize multiple times simultaneously
Promise.all([
  client.initialize(),  // Call 1
  client.initialize(),  // Call 2
  client.initialize(),  // Call 3
]);
```

**‚ùå WITHOUT Race Protection:**
```
Call 1 ‚Üí API Request 1 ‚Üí Fetch flags
Call 2 ‚Üí API Request 2 ‚Üí Fetch flags (DUPLICATE!)
Call 3 ‚Üí API Request 3 ‚Üí Fetch flags (DUPLICATE!)

Result: 3 API calls for same data! üò±
```

**‚úÖ WITH Race Protection:**
```
Call 1 ‚Üí Start fetch ‚Üí this.initializing = Promise
Call 2 ‚Üí Wait for Call 1's promise
Call 3 ‚Üí Wait for Call 1's promise

Result: 1 API call, all callers wait for same fetch! ‚úÖ
```

### Visual Flow: Concurrent Calls

```
Timeline ‚Üí

T0: Call 1 arrives
    ‚Üì
    Check: initialized? NO
    Check: initializing? NO
    Start fetch: this.initializing = fetchFlags()
    State: { initialized: false, initializing: Promise (pending) }

T1: Call 2 arrives (while Call 1 is still fetching)
    ‚Üì
    Check: initialized? NO
    Check: initializing? YES! ‚Üê There's already a promise
    ‚Üì
    Return this.initializing  ‚Üê Wait for the SAME promise

T2: Call 3 arrives (while Call 1 is still fetching)
    ‚Üì
    Check: initialized? NO
    Check: initializing? YES! ‚Üê There's already a promise
    ‚Üì
    Return this.initializing  ‚Üê Wait for the SAME promise

T3: API responds
    ‚Üì
    All three callers' promises resolve simultaneously
    State: { initialized: true, initializing: null }
```

### The Code That Enables This

```typescript
async initialize(): Promise<void> {
  // Already done? Return immediately (Idempotent)
  if (this.initialized) {
    return;
  }

  // In progress? Wait for existing promise (Race Protection)
  if (this.initializing) {
    return this.initializing;  // ‚Üê KEY LINE!
  }

  // Start new initialization
  this.initializing = this.fetchFlags();

  try {
    await this.initializing;
    this.initialized = true;
  } finally {
    this.initializing = null;  // Clear promise (success or failure)
  }
}
```

## Pattern 3: State Machine

The client has **3 states**:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ UNINITIALIZED   ‚îÇ  ‚Üê Initial state after construction
‚îÇ                 ‚îÇ
‚îÇ initialized: false
‚îÇ initializing: null
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì initialize() called
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ INITIALIZING    ‚îÇ  ‚Üê API call in progress
‚îÇ                 ‚îÇ
‚îÇ initialized: false
‚îÇ initializing: Promise
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì API responds
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ INITIALIZED     ‚îÇ  ‚Üê Ready to use
‚îÇ                 ‚îÇ
‚îÇ initialized: true
‚îÇ initializing: null
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### State Transitions

```
UNINITIALIZED ‚Üí INITIALIZING
  Trigger: First initialize() call
  Action: Start API fetch

INITIALIZING ‚Üí INITIALIZED
  Trigger: API success
  Action: Set flags, mark as initialized

INITIALIZING ‚Üí UNINITIALIZED
  Trigger: API failure
  Action: Clear initializing promise, stay uninitialized
```

### Handling Each State

```typescript
const client = new FeatureFlagClient({...});

// State: UNINITIALIZED
console.log(client.isInitialized());  // false

try {
  client.isEnabled('foo');
  // ‚ùå Throws: "Client not initialized. Call initialize() first."
} catch (error) {
  // User is forced to initialize first
}

// State: INITIALIZING (briefly)
await client.initialize();

// State: INITIALIZED
console.log(client.isInitialized());  // true
client.isEnabled('foo');  // ‚úÖ Works now
```

## Real-World Analogy

Think of `initialize()` like **turning on your car:**

**Without initialize pattern:**
```
Buy car ‚Üí Engine starts automatically (constructor)
  ‚Üì
What if you're not ready to drive?
What if there's no gas?
Can't catch errors during purchase!
```

**With initialize pattern:**
```
Buy car ‚Üí Just gets keys (constructor)
  ‚Üì
Turn ignition ‚Üí Engine starts (initialize)
  ‚Üì
Can handle:
  - No gas? Try/catch
  - Not ready? Wait to turn ignition
  - Already running? Ignition does nothing (idempotent)
```

## The Complete FeatureFlagClient API

### Lifecycle Methods

```typescript
// Create client (instant, no API call)
const client = new FeatureFlagClient({
  projectId: 'my-project',
  environment: 'PRODUCTION',
  baseUrl: 'https://api.peekaboo.com',  // optional
  timeout: 10000                         // optional
});

// Initialize (fetches flags)
await client.initialize();

// Refresh (re-fetch flags)
await client.refresh();

// Check state
client.isInitialized();  // boolean
```

### Flag Access Methods

```typescript
// Get full flag object
const flag = client.getFlag('new-checkout');
if (flag) {
  console.log(flag.key, flag.enabled, flag.value);
}

// Get all flags
const allFlags = client.getAllFlags();
console.log(`Loaded ${allFlags.length} flags`);

// Check if enabled (simple boolean)
if (client.isEnabled('new-checkout')) {
  // Feature is on
}

// Get typed value
interface CheckoutConfig {
  timeout: number;
  retries: number;
}

const config = client.getValue<CheckoutConfig>('new-checkout');
if (config) {
  console.log(config.timeout);  // TypeScript knows this exists
}

// Get value with fallback
const timeout = client.getValueWithFallback<number>('timeout', 5000);
console.log(timeout);  // Flag value or 5000 if not found
```

### Utility Methods

```typescript
// Count flags
console.log(`Loaded ${client.size()} flags`);

// Check initialization state
if (!client.isInitialized()) {
  await client.initialize();
}
```

## Key Implementation Details

### Config Validation (Fail Fast)

```typescript
constructor(config: ClientConfig) {
  // Validate immediately on construction
  const projectId = config.projectId.trim();
  if (!projectId) {
    throw new PeekabooError(
      'projectId is required',
      ErrorCode.INVALID_PROJECT_ID
    );
  }

  if (!config.environment) {
    throw new PeekabooError(
      'environment is required',
      ErrorCode.INVALID_ENVIRONMENT
    );
  }

  // Setup HTTP client
  const baseUrl = config.baseUrl || 'http://localhost:6001';
  this.http = new HttpClient(baseUrl, config.timeout);
}
```

**Why fail fast?**
- User knows immediately if config is wrong
- Better than failing later during initialize()
- Clear error messages guide user to fix

### In-Memory Caching with Map

```typescript
private flags: Map<string, FeatureFlag> = new Map();

// Populate cache
response.flags.forEach((flag) => {
  this.flags.set(flag.key, flag);  // O(1) insert
});

// Fast lookups
getFlag(key: string): FeatureFlag | null {
  return this.flags.get(key) || null;  // O(1) lookup
}
```

**Why Map instead of Array?**

```typescript
// ‚ùå Array: O(n) lookup
const flags: FeatureFlag[] = [...];
const flag = flags.find(f => f.key === 'new-checkout');  // Loops through all

// ‚úÖ Map: O(1) lookup
const flags = new Map<string, FeatureFlag>();
const flag = flags.get('new-checkout');  // Instant hash lookup
```

### Ensure Initialized Guard

```typescript
private ensureInitialized(): void {
  if (!this.initialized) {
    throw new PeekabooError(
      'Client not initialized. Call initialize() first.',
      ErrorCode.UNKNOWN
    );
  }
}

// Used in all flag access methods
getFlag(key: string): FeatureFlag | null {
  this.ensureInitialized();  // ‚Üê Throws if not initialized
  return this.flags.get(key) || null;
}
```

**Forces proper usage:**
```typescript
const client = new FeatureFlagClient({...});

// ‚ùå This will throw
client.isEnabled('foo');
// Error: "Client not initialized. Call initialize() first."

// ‚úÖ This works
await client.initialize();
client.isEnabled('foo');  // Works!
```

### Type-Safe Value Access

```typescript
getValue<T = unknown>(key: string): T | undefined {
  this.ensureInitialized();
  const flag = this.flags.get(key);

  // Only return value if flag exists AND is enabled
  if (flag && flag.enabled) {
    return flag.value as T;
  }

  return undefined;
}
```

**Usage patterns:**

```typescript
// Pattern 1: Check undefined
const timeout = client.getValue<number>('timeout');
if (timeout !== undefined) {
  console.log(timeout * 2);
}

// Pattern 2: Use fallback
const timeout = client.getValueWithFallback<number>('timeout', 5000);
console.log(timeout);  // Always has a value

// Pattern 3: Complex types
interface CheckoutConfig {
  timeout: number;
  retries: number;
  apiUrl: string;
}

const config = client.getValue<CheckoutConfig>('checkout-config');
if (config) {
  // TypeScript knows config has timeout, retries, apiUrl
  console.log(config.timeout);
}
```

## Key Lessons

### 1. Lazy Loading > Eager Loading

**Don't fetch until needed:**
- Faster construction
- User controls timing
- Errors are handleable

### 2. Idempotency Prevents Bugs

**Safe to call multiple times:**
- React effects can call freely
- No duplicate API calls
- Predictable behavior

### 3. Race Protection is Critical

**Concurrent calls must wait for same fetch:**
- Only ONE API call
- All callers get same result
- No race conditions

### 4. State Machines Clarify Logic

**Three clear states:**
- UNINITIALIZED: Created, not ready
- INITIALIZING: Fetching from API
- INITIALIZED: Ready to use

### 5. Fail Fast with Clear Errors

**Validate immediately:**
- Constructor validates config
- Methods throw if not initialized
- Clear error messages guide users

### 6. O(1) Lookups with Map

**Map > Array for lookups:**
- Constant time access
- Scales to thousands of flags
- No performance degradation

# Used in Projects

- **Peek-a-boo React SDK** - Complete vanilla TypeScript client for feature flags
- Pattern applicable to any SDK requiring initialization and caching

# Next Steps

With the vanilla TypeScript client complete (types, HTTP client, FeatureFlagClient), Phase 2 will wrap this in React hooks (useFeatureFlag, useFeatureFlags) and Context for easy integration into React apps.